<?php
/**
 * @file
 * Code for the ma_importexport feature.
 */

include_once('ma_importexport.features.inc');

/**
 * Implements hook_menu().
 */
function ma_importexport_menu() {
  $items = array();
  
  // "Export Item" button for DH node
  $items['node/%node/export-item'] = array(
    'title' => 'Export Item',
    'page callback' => 'ma_importexport_export_gui',
    'page arguments' => array(1),
    'access callback' => 'ma_importexport_access_export',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 105,
  );

  return $items;
}


/**
 * Implements hook_feeds_presave().
 */
function ma_importexport_feeds_presave(FeedsSource $source, $entity, $item) {

  // Custom handling of Youtube and Vimeo URLs
  // This code is adapted from _ma_services_create_atom, which itself is adapted from scald provider code as commented there

  if ($entity->type == 'digital_heritage') {

    foreach ($item['media assets'] as $media_asset_index => $media_asset) { // There can be multiple media assets in a single cell, separated by comma (feeds tamper explode), so loop through each

      if (substr ($media_asset, 0, 4) == 'http') { // the individual value must start with http/https in order to be identified as an externally-provided asset

        // A file scald atom has already been created for this by this point. Delete it, and unset the field.
        $already_created_sid = $entity->field_media_asset[LANGUAGE_NONE][$media_asset_index]['sid'];
        entity_delete ('scald_atom', $already_created_sid);
        $entity->field_media_asset[LANGUAGE_NONE][$media_asset_index] = '';

        // Youtube
        if (strpos($media_asset, 'youtube')) {
          $provider = 'youtube';
          $identifier = scald_youtube_parse_id($media_asset, TRUE);
          if ($identifier == FALSE) {
            drupal_set_message ('Skipped media asset due to invalid Youtube ID: ' . $media_asset, 'warning');
            continue;
          };
          if (!$sid = scald_youtube_already_imported($identifier)) {
            $video_identifier = $identifier['id'];
            $infos = scald_youtube_video($video_identifier);
          }
        }

        // Vimeo
        elseif (strpos($media_asset, 'vimeo')) {
          $provider = 'vimeo';
          $vimeo_id = substr(strrchr($media_asset, '/'), 1); // Vimeo parse function expects just the numeric ID, cannot parse whole URL
          $video_identifier = scald_vimeo_parse_id($vimeo_id, TRUE);
          if ($video_identifier == FALSE) {
            drupal_set_message ('Skipped media asset due to invalid Vimeo ID: ' . $media_asset, 'warning');
            continue;
          };
          if (!$sid = scald_vimeo_already_imported($video_identifier)) {
            $infos = scald_vimeo_video($video_identifier);
          }
        }

        // No provider match
        else {
          drupal_set_message ('Skipped media asset due to no matching provider: ' . $media_asset, 'warning');
          continue;
        }


        // Atom does not exist, needs to be created.
        if (!$sid) {
          $atom = new ScaldAtom('video', 'scald_' . $provider);
          $atom->base_id = $video_identifier;
          if (!isset($atom->data)) {
            $atom->data = array();
          }
          if (isset($identifier['list'])) {
            $atom->data['list'] = $identifier['list'];
          }
          $atom->title = $infos->title;

          // Save video width and height.
          $atom->data['video_width'] = $infos->width;
          $atom->data['video_height'] = $infos->height;

          // Download a copy of the video thumbnail. This makes it possible
          // to do interesting manipulation with image styles presets.
          $thumb = drupal_http_request($infos->thumbnail['src']);
          if ($thumb->code == 200 && $directory = ScaldAtomController::getThumbnailPath('video')) {
            $dest = $directory . '/' . $provider . '-' . $infos->id . '.jpg';
            $file = file_save_data($thumb->data, $dest);

            if ($file) {
              // Set the file status to temporary.
              $query = db_update('file_managed')
                ->condition('fid', $file->fid)
                ->fields(array('status' => 0))
                ->execute();
              $langcode = field_language('scald_atom', $atom, 'scald_thumbnail');
              $atom->scald_thumbnail[$langcode][0] = (array) $file;
            }
          }

          if (!$sid = scald_atom_save($atom)) {
            drupal_set_message ('Unable to save atom for: ' . $provider, 'warning');
            continue;
          }
        }

        // Set the Scald ID in the DH item's Media Asset field
        $entity->field_media_asset[LANGUAGE_NONE][$media_asset_index]['sid'] = $sid;

      }
    }
  }


  if($entity->feeds_item->entity_type == 'scald_atom') {
    if($entity->feeds_item->id == 'import_media_audio') {
      $type = 'audio';
    } elseif($entity->feeds_item->id == 'import_media_video') {
      $type = 'video';
    } else {
      return;
    }

    $path = ScaldAtomController::getThumbnailPath($type);
    try {
      $data = file_get_contents($entity->{'Temporary target 1'});
      $destination = (substr($path, -1) === '/' ? $path : $path . '/') . basename(urldecode($entity->{'Temporary target 1'}));
      $file = file_save_data($data, $destination, FILE_EXISTS_RENAME);
    } catch (Exception $e) {
      watchdog_exception('Feeds', $e, nl2br(check_plain($e)));
    }

    $entity->base_id = $file->fid;
    $entity->file_source = $file->uri;
    $entity->data[$type . '_file'] = $file->uri;
    $entity->data[$type . '_id'] = $file->fid;
  }
}

function ma_importexport_export_form_submit($form, &$form_state)
{
  //  dpm($form['dh_export']['items']['#value']);
  //  dpm($form['dh_export']['format']['#value']);

  ma_importexport_digital_heritage_node_export($form['dh_export']['items']['#value'],$form['dh_export']['format']['#value']);
}

function ma_importexport_export_form($form, &$form_state, $items, $format="csv") {
  $form = array();

  $form['dh_export']['items'] = array( '#type' => 'hidden', '#value' => $items);
  //  $form['dh_export']['export_format'] = array( '#type' => 'hidden', '#value' => 'csv');

  // Export Format
  $options = array('csv' => t('CSV'), 'xml' => t('XML'), 'json' => t('JSON'));
  $form['dh_export']['format'] = array( '#type' => 'radios',
					'#title' => t('Export Format'),
					'#default_value' => $format,
					'#options' => $options,
					);
  
  $form['dh_export']['export'] = array( '#type' => 'submit',
					'#value' => t('Export'),
					);
					

  return $form;
}

function ma_importexport_export_gui($items = NULL, $format = 'csv', $delivery = NULL) {
  if (is_int($items)) {
    $items = array($items);
  }
  elseif (is_object($items)) {
    $items = array($items->nid);
  }					

  return drupal_get_form('ma_importexport_export_form', $items, $format);
}

function ma_importexport_access_export($node) {
  global $user;
  if (is_int($node)) {
    $node = node_load($node);
  }

  if (function_exists('drush_main')) {
    // Always allow drush to export nodes.
    $access = TRUE;
  }
  else {
    // Check basic role permissions first.
    $access = TRUE;
    //    $access = (user_access('export nodes') || ($user->uid && ($node->uid == $user->uid) && user_access('export own nodes')));
    // Make sure the user can view the original node content.
    $access = $access && node_access('view', $node);
  }

  // Let other modules alter this - for example to only allow some users
  // to export specific nodes or types.
  //  drupal_alter("node_export_access_export", $access, $node);
  return $access;
}

function ma_importexport_digital_heritage_field_export($item, $field_name) {
  //  dpm($field_name);
  $result = array();
  
  switch($field_name) {
  case 'body':
    foreach($item->{$field_name}[$item->language] as $field_value) {
      $result[] = $field_value['value']; 
    }
    break;
  case 'field_media_asset':
    foreach($item->{$field_name}[LANGUAGE_NONE] as $field_value) {
      $result[] = $field_value['sid']; 
    }
    break;
  case 'field_category':
  case 'field_tags':
    foreach($item->{$field_name}[$item->language] as $term) {
      $result[] = taxonomy_term_load($term['tid'])->name;
    }
    break;
  case 'field_creator':
  case 'field_contributor':
  case 'field_dh_type':
  case 'field_format':
  case 'field_language':
  case 'field_publisher':
  case 'field_subject':
    foreach($item->{$field_name}[LANGUAGE_NONE] as $term) {
      $result[] = taxonomy_term_load($term['tid'])->name;
    }
    break;
  case 'field_book_children':
  case 'field_book_parent':
  case 'field_collection':
  case 'field_community_record_children':
  case 'field_community_record_parent':
  case 'field_related_dh_items':
  case 'og_group_ref':
    foreach($item->{$field_name}[LANGUAGE_NONE] as $ref) {
      $result[] = $ref['target_id'];
    }
    break;
  case 'field_community_ref':
    foreach($item->{$field_name}[LANGUAGE_NONE] as $ref) {
      $result[] = $ref['nid'];
    }
    break;
  case 'field_coverage':
    foreach($item->{$field_name}[LANGUAGE_NONE] as $ref) {
      $result[] = $ref['geom'];
    }
    break;
  default:
    foreach($item->{$field_name}[LANGUAGE_NONE] as $field_value) {
      $result[] = $field_value['value']; 
    }
  }

  return $result;
}

function ma_importexport_digital_heritage_node_export($items, $format = 'csv', $msg_t = 't') {
  global $user;

  if (is_int($items)) {
    $items = array($items);
  }
  elseif (is_object($items)) {
    $items = array($items->nid);
  }

  // Add any related items we need to export as well
  // TODO: restructure this to avoid looping over and loading all nodes twice
  $related_items = array();
  foreach($items as $item) {    
    $original_node = node_load($item);
    if(!empty($original_node->field_community_record_children)) {
      $related_items = array_merge($related_items, ma_importexport_digital_heritage_field_export($original_node, 'field_community_record_children'));
    }
    if(!empty($original_node->field_community_record_parent)) {
      $related_items = array_merge($related_items, ma_importexport_digital_heritage_field_export($original_node, 'field_community_record_parent'));
    }
    if(!empty($original_node->field_book_children)) {
      $related_items = array_merge($related_items, ma_importexport_digital_heritage_field_export($original_node, 'field_book_children'));
    }
    if(!empty($original_node->field_book_parent)) {
      $related_items = array_merge($related_items, ma_importexport_digital_heritage_field_export($original_node, 'field_book_parent'));
    }
  }

  // Merge and dedup list of top level items and related items
  $dh_items = array_merge($items, $related_items);
  $dh_items = array_unique($dh_items);

  // Get list of DH field names
  $dhfields = field_info_instances('node', 'digital_heritage');

  // Load mapping from Digial Heritage Metadata importer to look up header names
  ctools_include('export');
  $mapping = array();
  if ($config = ctools_export_load_object('feeds_importer', 'conditions', array('id' => 'digital_heritage_metadata'))) {
    $config = array_shift($config);
    foreach($config->config['processor']['config']['mappings'] as $map) {
      $mapping[$map['target']] = $map['source'];
    }
  }

  $export_items = array();
  
  // Add headers
  foreach($dhfields as $dhfield) {
      $export_items['headers'][$dhfield['field_name']] = $mapping[$dhfield['field_name']];
  }
  
  // Process Items
  foreach ($dh_items as $item) {
    $original_node = node_load($item);

    if (!ma_importexport_access_export($original_node)) {
      $error = $msg_t("You do not have permission to export one or more of these items.  No items exported.");
      return array(
        'success' => FALSE,
        'output' => array($error),
      );
    }

    $export_item = array();

    // nid
    $export_item['nid'] = array($original_node->nid);
    
    // Title
    $export_item['title'] = array($original_node->title);

    // Loop through DH specific fields
    foreach($dhfields as $dhfield) {
      $field_export = NULL;
      if(!empty($original_node->{$dhfield['field_name']})) {
	$field_export = ma_importexport_digital_heritage_field_export($original_node, $dhfield['field_name']);
      }
      $export_item[$dhfield['field_name']] = $field_export;
    }

    $export_items['items'][] = $export_item;
  }

  dpm($original_node);

  //  dpm($export_items);
  ma_importexport_export_csv($export_items);
  

  drupal_set_message(t('Exported ') . $original_node->title);
}

function ma_importexport_export_csv($export_items, $delimiter='||') {
  //drupal_add_http_header('Content-Type', 'text/csv; utf-8');
  //  drupal_add_http_header('Content-Disposition', 'attachment;filename=csvfiles.csv');

  // Prevent Devel from messing us up.
  $GLOBALS['devel_shutdown'] = TRUE;
  
  // Set the headers to indicate this is a CSV file.
  header('Content-type: text/csv; charset=UTF-8');
  header('Content-Disposition: attachment; filename=item_export.csv');
  header('Pragma: no-cache');
  header('Expires: 0');
  
  $output = fopen('php://output', 'w');

  // Write headers
  $headers = array();
  foreach($export_items['items'][0] as $key => $name) {
    $headers[] = $export_items['headers'][$key] ? $export_items['headers'][$key] : $key;
  }

  //  dpm($headers);
  fputcsv($output, $headers);

  // Write items
  foreach($export_items['items'] as $item) {
    $item_array = array();
    foreach($item as $field => $value) {
      $item_array[] = implode($delimiter, $value);
    }
    //  dpm($item_array);
    fputcsv($output, $item_array);
  }
  
  fclose($output);
  drupal_exit();
}