<?php
/**
 * @file
 * Code for the Digital Heritage Metadata Import feature.
 */

include_once('ma_digitalheritage.features.inc');

/**
 * Implements hook_node_presave().
 */
function ma_digitalheritage_node_presave($node) {
  if ($node->type == 'digital_heritage') {

    $dh_emw = entity_metadata_wrapper('node', $node);

    // Set the community record parent if the session var for such was set in ma_digitalheritage_form_digital_heritage_node_form_alter
    if (isset ($_SESSION['community_record_parent'])) {
      $node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'] = $_SESSION['community_record_parent'];
      unset ($_SESSION['community_record_parent']);
    }

    // Update the Community field according to the protocols for the DH node. The community field is a noderef field hidden from the node form, but displayed on the node view and search results view (and used as a search facet). It is a hidden noderef field (as opposed to group field) because we can only have one group field per node type and that's already used for the protocol.
    $communities = array();
    foreach ($dh_emw->og_group_ref->value() as $protocol) {
      $p_emw = entity_metadata_wrapper('node', $protocol);
      foreach ($p_emw->og_group_ref->value() as $community) {
        $communities[] = $community->nid;
      }
    }
    if (count($communities)) {
      $dh_emw->field_community_ref->set(array_unique($communities));
    }

  }
}
/**
 * Implements hook_node_update().
 */
function ma_digitalheritage_node_update($node) {
  if ($node->type == 'digital_heritage') {

    $dh_emw = entity_metadata_wrapper('node', $node);
    $dh_emw_old = entity_metadata_wrapper('node', $node->original);

    // If this is a Book Parent, replicate some field values to its book children
    $book_children = $dh_emw->field_book_children->value();
    if (count($book_children)) {

      // Replicate the Protocols (if changed) (their Communities will get set in their own wrapper save below)
      if (array_values($dh_emw->og_group_ref->value()) <> array_values($dh_emw_old->og_group_ref->value())) {
        foreach ($book_children as $child_page) {
          foreach ($dh_emw->og_group_ref->value() as $protocol) {
            $parent_protocols[] = $protocol->nid;
          }
          if (count($parent_protocols)) {
            $book_child_wrapper = entity_metadata_wrapper('node', $child_page);
            $book_child_wrapper->og_group_ref->set(array_unique($parent_protocols));
            $book_child_wrapper->save();
          }
        }
        #dpm ('groups changed on children');
      }

      // Replicate the privacy setting (if changed)
      if ($dh_emw->field_item_privacy_setting->value() <> $dh_emw_old->field_item_privacy_setting->value()) {
        foreach ($book_children as $child_page) {
          $book_child_wrapper = entity_metadata_wrapper('node', $child_page);
          $book_child_wrapper->field_item_privacy_setting->set($dh_emw->field_item_privacy_setting->value());
          $book_child_wrapper->save();
        }
        #dpm ('privacy setting changed on children');
      }

    }
  }
}


/**
 * Implements hook_form_FORM_ID_alter().
 */
function ma_digitalheritage_form_views_exposed_form_alter(&$form, &$form_state) {

  // Add a button to reset search and filters
  // Search API provides a button on the view that will reset the search, but not the filters. Leaving that off and creating our own that will reset both.
  if (strpos($form['#id'], 'views-exposed-form-digital-heritage-grid-list') !== FALSE) {
    if (count(arg()) > 1 OR count(drupal_get_query_parameters())) {
      $form['reset'] = array('#markup' => l(t('Reset'),'digital-heritage', array('attributes' => array('class' => array ('btn', 'btn-primary', 'form-submit')), 'html' => TRUE)));
    }
  }

}

/**
 * Implements template_preprocess_views_view.
 */
function ma_digitalheritage_preprocess_views_view(&$vars) {
  $view = &$vars['view'];

  // Add JS for grid/list view switcher on DH and Collections views
  if ($view->name == 'digital_heritage_grid_list' OR $view->name == 'collections_grid_list') {
    drupal_add_library('system', 'jquery.cookie');
    drupal_add_js(drupal_get_path('module', 'ma_digitalheritage') . '/js/grid_list_switcher.js');
  }
}

/**
 * Implements hook_user_logout().
 */
// Delete the cookie that holds the DH grid/list view setting
function ma_digitalheritage_user_logout ($account) {
  setcookie('grid_list_mode', '', 1, '/');
}

/**
 * Implementation of hook_node_view().
 */
function ma_digitalheritage_node_view($node, $view_mode) {
  if ($view_mode == 'search_result') {

    // Tooltip and links on DH grid/list views


    // If no media items at all on the DH item and in grid view, put a placeholder image
    if (!count($node->field_media_asset)) {
      $node->content['field_media_asset'][0]['#markup'] = '
      <div class="col-md-4 col-md-push-8 field field-name-field-media-asset field-type-atom-reference field-label-hidden">
        <div class="field-items">
            <a class = "tooltips image-placeholder" href=" ' . url("node/" . $node->nid) . '"><img src = "/' . drupal_get_path('module', 'ma_digitalheritage') . '/images/no_media_available.jpg"></a>
        </div>
      </div>';
    }

  }

  elseif ($view_mode == 'full') {

    // Rewrite the Related DH Items reference field as paged, since there can be hundreds. This is a dupe of the same thing in ma_collection_node_view. See comments there if changing here, should also be changed there.

    $dh_items_per_page = 10;

    // Build the array of all DH items
    if (isset($node->field_related_dh_items[LANGUAGE_NONE])) {
      $all_dh_items = array();
      foreach ($node->field_related_dh_items[LANGUAGE_NONE] as $index => $dh_item) {
        unset ($node->content['field_related_dh_items'][$index]); // Start rewriting the field by removing the existing DH items
        if (node_access('view', $dh_item['entity'])) {
          $dh_node = node_view($dh_item['entity'], 'search_result');
          $all_dh_items[] = drupal_render($dh_node); // Need to render here as opposed to using "rendered entity" in the DS display, as that will attemt to render them *after* this hook runs
        }
      }

      // Initialise the pager
      $current_page = pager_default_initialize(count($all_dh_items), $dh_items_per_page);

      // Split all DH items into pages
      $pages = array_chunk($all_dh_items, $dh_items_per_page, TRUE);

      // Print the DH items for the current page
      $output = "";
      foreach ($pages[$current_page] as $dh_item_to_display) {
        $output .= $dh_item_to_display;
      }

      // Print the pager
      $output .= theme('pager', array('quantity', count($dh_items_per_page)));

      // Rewrite the field output
      $node->content['field_related_dh_items'][0]['#markup'] = $output;
    }


  }
  elseif ($view_mode == 'community_record') {

    // Add an edit link to community record after its title
    $node->content['title'][0]['#markup'] = $node->title . l (' (edit)', 'node/' . $node->nid . '/edit');
  }


}

/**
 * Implements hook_comment_insert().
 */
function ma_digitalheritage_comment_insert($comment) {

  // Notify protocol steward(s) when a comment has been posted to one of their Cultural Protocols that requires approval
  if ($comment->node_type == 'comment_node_digital_heritage') {
    if ($comment->status) return; // comment is pre-approved (eg. posted by admin)
    $dh_emw = entity_metadata_wrapper('node', $comment->nid);

    // Build the array of protcol manager emails from the protocol steward(s) of the given protocol(s) for this DH node
    if ($cps = $dh_emw->og_group_ref->value()) {
      $protocol_managers_emails = array();
      foreach ($cps as $cp) {
        $cp_emw = entity_metadata_wrapper('node', $cp);
        if ($protocol_managers = ma_core_og_get_users_per_role_and_group ('protocol steward', 'cultural_protocol_group', $cp->nid)) {
          foreach ($protocol_managers as $protocol_manager) {
            $protocol_managers_emails[] = $protocol_manager->name . ' <' . $protocol_manager->mail . '>';
          }
        }
      }

      // Send the email (the body and subject get built in ma_digitalheritage_mail)
      if (count($protocol_managers_emails)) {
        $params = array (
          'comment' => $comment,
          'cp_emw' => $cp_emw,
          'dh_emw' => $dh_emw,
          'recipient_count' => count ($protocol_managers_emails),
        );
        drupal_mail('ma_digitalheritage', 'dh_comment_notification', implode (', ', $protocol_managers_emails), language_default(), $params);
      }
    }
  }
}

/*
 * Implementation of hook_mail().
*/
function ma_digitalheritage_mail($key, &$message, $params) {
  switch ($key) {
    case 'dh_comment_notification':
      $comment = $params['comment'];
      $cp_title = $params['cp_emw']->title->value();

      // Set the email subject
      $message['subject'] = "A comment in '" . $cp_title . "' requires your approval";

      // Set the email body
      $email_body  = "A comment has been posted that requires your approval.\n\n";
      $email_body .= "Cultural Protocol:\n" . $cp_title . "\n\n";
      $email_body .= "Digital Heritage:\n" . $params['dh_emw']->title->value() . "\n\n";
      $comment_author = user_load ($comment->uid);
      $email_body .= "Comment author:\n" . $comment_author->name . "\n\n";
      if ($comment->subject) {
        $email_body .= "Comment subject:\n". $comment->subject . "\n\n";
      }
      $comment_body = $comment->comment_body[LANGUAGE_NONE][0]['value'];
      $comment_body = drupal_html_to_text ($comment_body);
      $email_body  .= "Comment body:\n" . $comment_body . "\n\n";
      $email_body .= "Click " . l('here', 'node/' . $comment->nid, array('fragment' => 'comment-' . $comment->cid)) . " to approve or delete this comment";
      if ($params['recipient_count'] > 1) {
        $email_body .= " (more than one Protocol Stewards have received this notification, so the comment may already be approved or deleted at this time)";
      }
      $email_body .= ".";
      $message['body'][] = $email_body;

      break;
  }
}

/**
 * Implements hook_views_pre_build().
 */
function ma_digitalheritage_views_pre_build(&$view) {

  // Override the "View All" (DH Items) path to the sapi page
  if ($view->name == 'community_dh_items') {
    $view->override_path = 'digital-heritage/' . $view->current_display;
  }
}

/**
 * Implements hook_menu().
 */
function ma_digitalheritage_menu() {
  $items = array();

  // "Duplicate Item" button for DH node
  $items['node/%node/duplicate-item'] = array(
    'title' => 'Duplicate Item',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ma_digitalheritage_clone_dh_form', 1),
    'access callback' => 'ma_digitalheritage_clone_dh_button_check',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  );

  // "Add Community Record" button for DH node
  $items['node/%node/add-community-record'] = array(
    'title' => 'Add Community Record',
    'page callback' => 'ma_digitalheritage_add_community_record',
    'page arguments' => array(1),
    'access callback' => 'ma_digitalheritage_clone_dh_button_check',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  );

  // "Add a Book Page" button for DH node
  $items['node/%node/add-book-page'] = array(
    'title' => 'Add a Book Page',
    'page callback' => 'ma_digitalheritage_add_book_page',
    'page arguments' => array(1),
    'access callback' => 'ma_digitalheritage_add_book_page_check',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  );

  return $items;
}

function ma_digitalheritage_clone_dh_button_check($node) {
  if ($node->type == 'digital_heritage') {
    $dh_emw = entity_metadata_wrapper('node', $node);
    if ($dh_emw->field_book_parent->value() OR $dh_emw->field_book_children->value()) { // Do not allow cloning or creating community records on book pages, whether child or parent
      return FALSE;
    }
    foreach ($dh_emw->og_group_ref->value() as $protocol) {
      if (isset ($protocol)) {
        $p_emw = entity_metadata_wrapper('node', $protocol);
        $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
        if (array_intersect(array('protocol steward'), $roles_for_user_in_group)) {
          return TRUE;
        }
      }
    }
  }
}

function ma_digitalheritage_add_book_page_check($node) {
  if ($node->type == 'digital_heritage') {
    $dh_emw = entity_metadata_wrapper('node', $node);
    if ($dh_emw->field_community_record_parent->value() OR $dh_emw->field_community_record_children->value()) { // Do not allow creating book pages on community records
      return FALSE;
    }
    global $user;
    if ($node->uid == $user->uid) { // Only owners of nodes can create child book pages for it
      return TRUE;
    }
  }
}

function ma_digitalheritage_clone_dh_form($form, $form_state, $node) {
  $question = "<i>Duplicate Digital Heritage Item</i> " . $node->title;
  $description = "<div>Are you sure?</div>";
  return confirm_form($form, $question, 'node/' . $node->nid, $description);
}

function ma_digitalheritage_clone_dh_form_submit($form, $form_state) {

  // Clone the node with a new title
  $original_nid = arg(1);
  $cloned = replicate_clone_entity_by_id ('node', $original_nid);
  $cloned->title = $cloned->title . ' - copy';
  node_save ($cloned);

  // Unset any CPs that the cloning protocol steward is not a contributor or protocol steward for
  $protocols_to_set = array();
  $dh_emw = entity_metadata_wrapper('node', $cloned);
  foreach ($dh_emw->og_group_ref->value() as $protocol) {
    $p_emw = entity_metadata_wrapper('node', $protocol);
    $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
    if (array_intersect(array('protocol steward', 'contributor'), $roles_for_user_in_group)) {
      $protocols_to_set[] = $protocol;
    }
  }
  $dh_emw->og_group_ref->set ($protocols_to_set);

  // Make a relationship to the original node
  $dh_emw->field_related_dh_items[] = $original_nid;

  // Save our changes
  $dh_emw->save();

  // Go to the cloned node
  drupal_set_message(t("Successfully duplicated Digital Heritage item"));
  drupal_goto ('node/' . $cloned->nid);
}

// When renaming a cloned node, do not create a URL redirect from the old node, because a newly cloned node from the original node might take the original path of 1st cloned node, thus you would always be redirected to the 1st cloned node from the 2nd cloned node. This is not an edge case. It would happen in normal node cloning workflow, as it did during our tests.
function ma_digitalheritage_redirect_presave($redirect) {
  if (strpos($redirect->source, '-copy')) {
    $redirect->source = "dh_clone_redirect"; // cannot simply unset the $redirect here so setting a dummy source instead
  }
}


// "Add Community Record" button redirect to node edit form with community-record param
function ma_digitalheritage_add_community_record ($node) {
  drupal_goto ('node/add/digital-heritage/community-record/' . $node->nid);
}

// "Add a Book Page" button redirect to node edit form with book-page param
function ma_digitalheritage_add_book_page ($node) {
  drupal_goto ('node/add/digital-heritage/book-page/' . $node->nid);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ma_digitalheritage_form_digital_heritage_node_form_alter(&$form, &$form_state) {

  // Always hide these fields
  $form['field_book_parent']['#access'] = FALSE;

  // Grab Community Record parent on node edit and set page title
  if (isset($form['field_community_record_parent'][LANGUAGE_NONE]['#default_value'][0])) {
    $community_record_parent_wrapper = entity_metadata_wrapper('node', $form['field_community_record_parent'][LANGUAGE_NONE]['#default_value'][0]);

    // Set the page title
    drupal_set_title ("<i>Edit Community Record</i> " . $form['#node']->title . " <i>in</i> " . $community_record_parent_wrapper->title->value(),  PASS_THROUGH);
  }

  // On Community Record add, ensure the user actually has permission to create a community record on this node, in case they hacked NID in the url, and then set the community record parent wrapper and page title, and then set the session var for community record parent.
  elseif (arg(3) == 'community-record') {
    $parent_dh_wrapper = entity_metadata_wrapper('node', arg(4));
    foreach ($parent_dh_wrapper->og_group_ref->value() as $protocol) {
      $p_emw = entity_metadata_wrapper('node', $protocol);
      $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
      if (array_intersect(array('protocol steward'), $roles_for_user_in_group)) {

        // Set the parent wrapper
        $community_record_parent_wrapper = $parent_dh_wrapper;

        // Set the page title
        drupal_set_title ("<i>Create Community Record in</i> " . $community_record_parent_wrapper->title->value(),  PASS_THROUGH);

        // Use a session var to set the parent community record nid. This then gets set in the child in ma_digitalheritage_node_presave. (we cannot set the field value here because it is a hidden form element)
        $_SESSION['community_record_parent'] = arg(4);

        break;
      }
    }
  }

  // Customizations to Community Record DH nodes
  if (isset($community_record_parent_wrapper)) {

    // Hide some fields
    $hide_fields = array(
      'field_media_asset',
      'field_collection',
      'field_related_dh_items',
      'field_community_record_children',
    );
    foreach ($hide_fields as $hide_field) {
      $form[$hide_field]['#access'] = FALSE;
    }

  }

  // Grab Book Page parent on node edit and set page title
  if ($form['field_book_parent'][LANGUAGE_NONE][0]['target_id']['#default_value']) {
    $book_child_page = 1;

    // Set the page title
    $book_parent = $form['field_book_parent'][LANGUAGE_NONE][0]['target_id']['#entity'];
    drupal_set_title ("<i>Edit Book Page</i> " . $form['#node']->title . " <i>in</i> " . $book_parent->title,  PASS_THROUGH);
  }

  // On Book Page add, ensure the user actually has permission to create a Book Page on this node, in case they hacked NID in the url, and then set the page title, set the parent, and set the protocols and privacy setting
  elseif (arg(3) == 'book-page') {
    $referring_node = node_load (arg(4));
    global $user;
    if (ma_digitalheritage_add_book_page_check($referring_node)) { // The permission check
      $book_child_page = 1;
      if (isset ($referring_node->field_book_parent[LANGUAGE_NONE][0]['target_id'])) { // This book child page is being added from another book child page
        $book_parent = node_load ($referring_node->field_book_parent[LANGUAGE_NONE][0]['target_id']);
      }
      else {
        $book_parent = $referring_node; // This book child page is being added from the parent book page
      }

      // Set the page title
      drupal_set_title ("<i>Create Book Page in</i> " . $book_parent->title,  PASS_THROUGH);

      // Set the parent
      $form['field_book_parent'][LANGUAGE_NONE][0]['target_id']['#value'] = $book_parent->title . ' (' . $book_parent->nid . ')'; // setting in the autocomplete widget format

      // Set the privacy setting to that of the parent
      $book_parent_wrapper = entity_metadata_wrapper('node', $book_parent);
      $form['field_item_privacy_setting'][LANGUAGE_NONE]['#value'] = $book_parent_wrapper->field_item_privacy_setting->value();

      // Set the protocol(s) to that of the parent (its communities will get set in hook_node_presave)
      $parent_protocols = array();
      foreach ($book_parent_wrapper->og_group_ref->value() as $protocol) {
        $parent_protocols[] = $protocol->title . ' (' . $protocol->nid . ')'; // setting in the autocomplete widget format
      }
      if (count($parent_protocols)) {
        $default_protocols = implode (', ', $parent_protocols);
        $form['og_group_ref'][LANGUAGE_NONE][0]['default']['#default_value'][0] = $default_protocols;
      }
    }

  }

  // Customizations to Book Child Page
  if (isset($book_child_page)) {
    $hide_fields = array(
      'field_item_privacy_setting',
      'field_book_children',
      'field_community_record_children',
      'field_related_dh_items',
      'field_collection',
    );
    foreach ($hide_fields as $hide_field) {
      $form[$hide_field]['#access'] = FALSE;
    }

  }

}

/**
 * Implements hook_node_validate().
 */
function ma_digitalheritage_node_validate($node, $form, &$form_state) {
  if ($node->type == 'digital_heritage') {

    // Do not allow adding, changing, or removing of Community Records in the DH node form. The field is there only to allow users to reorder the Community Records.
    $original_community_records = array();
    foreach ($form['field_community_record_children'][LANGUAGE_NONE] as $original_child) {
      if (isset($original_child['target_id'])) {
        $original_child_text = $original_child['target_id']['#default_value'];
        $original_child_numeric = substr(substr(strstr($original_child_text, '('), 0, -1), 1);
        if (is_numeric($original_child_numeric)) {
          $original_community_records[] = $original_child_numeric;
        }
      }
    }
    $new_community_records = array();
    foreach ($form_state['values']['field_community_record_children'][LANGUAGE_NONE] as $new_child) {
      if (isset($new_child['target_id']) && is_numeric($new_child['target_id'])) {
        $new_community_records[] = $new_child['target_id'];
        if (!in_array($new_child['target_id'], $original_community_records)) {
          form_set_error('field_community_record_children', t('Do not add Community Records here. Use the "Add Community Record" button instead.'));
        }
      }
    }
    foreach ($original_community_records as $original_child) {
      if (!in_array($original_child, $new_community_records)) {
        form_set_error('field_community_record_children', t('Do not remove Community Records here. Instead, edit the Community Record, then press "Delete". Note, only the creator of the Community Record can delete it.'));
      }
    }

    // Do not allow adding, changing, or removing of Book Pages in the DH node form. The field is there only to allow users to reorder the Book Pages.
    $original_book_pages = array();
    foreach ($form['field_book_children'][LANGUAGE_NONE] as $original_child) {
      if (isset($original_child['target_id'])) {
        $original_child_text = $original_child['target_id']['#default_value'];
        $original_child_numeric = substr(substr(strstr($original_child_text, '('), 0, -1), 1);
        if (is_numeric($original_child_numeric)) {
          $original_book_pages[] = $original_child_numeric;
        }
      }
    }
    $new_book_pages = array();
    foreach ($form_state['values']['field_book_children'][LANGUAGE_NONE] as $new_child) {
      if (isset($new_child['target_id']) && is_numeric($new_child['target_id'])) {
        $new_book_pages[] = $new_child['target_id'];
        if (!in_array($new_child['target_id'], $original_book_pages)) {
          form_set_error('field_book_children', t('Do not add Book Pages here. Use the "Add a Book Page" button instead.'));
        }
      }
    }
    foreach ($original_book_pages as $original_child) {
      if (!in_array($original_child, $new_book_pages)) {
        form_set_error('field_book_children', t('Do not remove Book Pages here. Instead, edit the Book Page, then press "Delete".'));
      }
    }

  }
}


/**
 * Implements hook_node_insert().
 */
function ma_digitalheritage_node_insert($node) {
  if ($node->type == 'digital_heritage') {

    // Create redirects on Community Record nodes to their parent
    if (isset($node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'])) {
      $redirect = new stdClass();
      redirect_object_prepare(
        $redirect,
        array(
          'source' => 'node/' . $node->nid,
          'source_options' => array(),
          'redirect' => 'node/' . $node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'],
          'redirect_options' => array(),
          'language' => LANGUAGE_NONE,
        )
      );
      redirect_save($redirect);
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function ma_digitalheritage_node_delete($node) {
  if ($node->type == 'digital_heritage') {
    $dh_emw = entity_metadata_wrapper('node', $node);

    // TODO: add a confirmation step
    // Delete the Community Records of a parent DH if the parent is deleted
    foreach ($dh_emw->field_community_record_children->value() as $child) {
      if (isset($child->nid)) {
        if ($child->nid <> $node->nid) { // In case a Community Record is a child of itself (which shouldn't happen but just in case to prevent infinite loop)
          node_delete($child->nid);
        }
      }
    }

    // TODO: add a confirmation step
    // Delete the child pages of a book if the parent is deleted
    foreach ($dh_emw->field_book_children->value() as $child) {
      if (isset($child->nid)) {
        if ($child->nid <> $node->nid) { // In case a book page is a child of itself (which shouldn't happen but just in case to prevent infinite loop)
          node_delete($child->nid);
        }
      }
    }

  }
}

/**
 * Implements hook_search_api_index_items_alter().
 *
 * Exclude Community Record DH nodes from being indexed
 */
function ma_digitalheritage_search_api_index_items_alter(array &$items, SearchApiIndex $index) {
  foreach($items as $id => $item){
    if (isset($item->field_community_record_parent[LANGUAGE_NONE])) {
     unset($items[$id]);
    }
  }
}


/**
 * Implements hook_node_load().
 */
function ma_digitalheritage_node_load($nodes, $types) {

  // For Community Records, show the parent record's atoms
  if (in_array('digital_heritage', $types)) {
    foreach ($nodes as $node) {
      if (isset($node->field_community_record_parent[LANGUAGE_NONE])) {
        $parent_node = node_load ($node->field_community_record_parent[LANGUAGE_NONE][0]['target_id']);
        if (isset($parent_node->field_media_asset[LANGUAGE_NONE])) {
          $node->field_media_asset = $parent_node->field_media_asset;
        }
      }
    }
  }
}

/**
 * Implements hook_page_alter().
 */
function ma_digitalheritage_page_alter(&$data) {


  // If there are Child Records for a DH node, show the parent and child records in quicktabs
  if (isset($data['content']['system_main']['nodes'])) {
    $array_keys = array_keys($data['content']['system_main']['nodes']);
    $node = $data['content']['system_main']['nodes'][array_shift($array_keys)]["#node"];
    if ($node->type == 'digital_heritage') {
      $nids = element_children($data['content']['system_main']['nodes']);
      $nid = $nids[0];
      $parent_dh = entity_metadata_wrapper('node', $nid);
      if ($community_records = $parent_dh->field_community_record_children->value()) {

        $tab_settings = array(
          'ajax' => 0,
          'default_tab' => 0,
          'title' => 'DH Tabs',
          'renderer' => 'quicktabs',
          'style' => 'Excel',
          'hide_empty_tabs' => 1,
        );

        // Parent tab
        $parent_parent_community = node_load($node->field_community_ref[LANGUAGE_NONE][0]['nid']);
        $dh_tabs[] = array(
          'type' => 'node',
          'nid' => $nid,
          'view_mode' => 'full',
          'title' => $parent_parent_community->title . ' Record',
          'hide_title' => 0,
          #'weight' => 0,
        );

        foreach ($community_records as $community_record) {

          global $user;
          if (mukurtu_protocol_field_node_access($community_record, 'view', $user) == 'allow') {

            // Tab title
            $community_record_parent_communities = array();
            foreach ($community_record->field_community_ref[LANGUAGE_NONE] as $community_record_parent_community) {
              $community_record_parent_community_node = node_load($community_record_parent_community['nid']);
              $community_record_parent_communities[] = $community_record_parent_community_node->title;
            }
            $community_record_tab_title = implode(' / ', $community_record_parent_communities) . ' Record';


            // Create the tab
            $dh_tabs[] = array(
              'type' => 'node',
              'nid' => $community_record->nid,
              'view_mode' => 'community_record',
              'title' => $community_record_tab_title,
              'hide_title' => 0,
              #'weight' => 0,
            );
          }

          // User does not have view access to the Community Record. Create an empty tab (which does not render) to maintain tab index for direct linking to tabs
          else {
            $dh_tabs[] = array(
            );
          }
        }

        $data['content']['system_main'] = array(
          'content' => quicktabs_build_quicktabs("community-record", $tab_settings, $dh_tabs),
          '#weight' => 99,
        );
      }
    }
  }
}

/**
 * Implements hook_ds_fields_info().
 */
function ma_digitalheritage_ds_fields_info($entity_type) {
  $fields = array();

  $fields['book_page_navigation'] = array(
    'title' => t('Book Page Navigation'),
    'field_type' => DS_FIELD_TYPE_FUNCTION,
    'ui_limit' => array('digital_heritage|full'),
    'function' => 'ma_digital_heritage_book_page_navigation_field'
  );

  return array('node' => $fields);
}

function ma_digital_heritage_book_page_navigation_field ($field) {
  $node = $field['entity'];

  $output = "";

  // Parent pages show a table of contents, plus the right arrow
  if ($node->field_book_children) {
    $toc = '<ol><li>' . $node->title .'</li>';
    $parent_emw = entity_metadata_wrapper('node', $node);
    $children = $parent_emw->field_book_children->value();
    foreach ($children as $child) {
      $toc .= '<li>' . l($child->title, 'node/' . $child->nid) . '</li>';
    }
    $toc .= '</ol>';
    $right = $children[0];
  }

  // Child pages show arrows left, right, and up arrows
  elseif ($node->field_book_parent) {
    $child_emw = entity_metadata_wrapper('node', $node);
    $parent_node = $child_emw->field_book_parent->value();
    $up = $parent_node;
    $parent_emw = entity_metadata_wrapper('node', $parent_node);
    $children = $parent_emw->field_book_children->value();
    foreach ($children as $child_index => $child) {
      if ($child->nid == $node->nid) {
        if (isset ($children[$child_index -1])) {
          $left = $children[$child_index -1];
        }
        if (isset ($children[$child_index +1])) {
          $right = $children[$child_index +1];
        }
        break;
      }
    }
  }

  // Render the navigation for all parent and child pages
  if (isset($children)) {
    global $base_url;
    $icon_path = $base_url . '/' . path_to_theme() . '/';
    $output .= '<div class = "dh-book-nav">';

    // Up arrow
    if (isset($up)) {
      $output .= '<div class = "dh-book-nav-top">' . l('<img src = "' . $icon_path . 'dh-nav-arrow-up.png">', 'node/' . $up->nid, array('html' => TRUE)) . '</div>';
    }

    // Middle arrows
    $output .= '<div class = "dh-book-nav-middle">';
    if (isset($left)) {
      $output .= '<span class = "dh-book-nav-left">' . l('<img src = "' . $icon_path . 'dh-nav-arrow-left.png">', 'node/' . $left->nid, array('html' => TRUE)) . '</span>';
    }

    if (isset($right)) {
      $output .= '<span class = "dh-book-nav-right">' . l('<img src = "' . $icon_path . 'dh-nav-arrow-right.png">', 'node/' . $right->nid, array('html' => TRUE)) . '</span>';
    }
    $output .= '</div>';

    // Plus button to add a child page if user is the node owner
    global $user;
    if ($node->uid == $user->uid) {
      $output .= '<div class = "dh-book-nav-bottom">' . l('<img src = "' . $icon_path . 'dh-nav-plus.png">', 'node/add/digital-heritage/book-page/' . $node->nid, array('html' => TRUE)) . '</div>';
    }

    // Table of contents (shows on first page only)
    if (isset ($toc)) {
      $output .= '<div class = "dh-book-nav-toc">' . $toc . '</div>';
    }

    $output .= '</div>';
    return $output;
  }

}