<?php
/**
 * @file
 * Code for the Digital Heritage Metadata Import feature.
 */

include_once('ma_digitalheritage.features.inc');

/**
 * Implements hook_node_presave().
 */
function ma_digitalheritage_node_presave($node) {
  if ($node->type == 'digital_heritage') {

    // Update the Community field according to the protocols for the DH node. The community field is a noderef field hidden from the node form, but displayed on the node view and search results view (and used as a search facet). It is a hidden noderef field (as opposed to group field) because we can only have one group field per node type and that's already used for the protocol.
    $communities = array();
    $dh_emw = entity_metadata_wrapper('node', $node);
    foreach ($dh_emw->og_group_ref->value() as $protocol) {
      $p_emw = entity_metadata_wrapper('node', $protocol);
      foreach ($p_emw->og_group_ref->value() as $community) {
        $communities[] = $community->nid;
      }
    }
    if (count($communities)) {
      $dh_emw->field_community_ref->set(array_unique($communities));
    }

    // Set the community record parent if the session var for such was set in ma_digitalheritage_form_digital_heritage_node_form_alter
    if (isset ($_SESSION['community_record_parent'])) {
      $node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'] = $_SESSION['community_record_parent'];
      unset ($_SESSION['community_record_parent']);
    }

  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ma_digitalheritage_form_views_exposed_form_alter(&$form, &$form_state) {

  // Add a button to reset search and filters
  // Search API provides a button on the view that will reset the search, but not the filters. Leaving that off and creating our own that will reset both.
  if (strpos($form['#id'], 'views-exposed-form-digital-heritage-grid-list') !== FALSE) {
    if (count(arg()) > 1 OR count(drupal_get_query_parameters())) {
      $form['reset'] = array('#markup' => l(t('Reset'),'digital-heritage', array('attributes' => array('class' => array ('btn', 'btn-primary', 'form-submit')), 'html' => TRUE)));
    }
  }

}

/**
 * Implements template_preprocess_views_view.
 */
function ma_digitalheritage_preprocess_views_view(&$vars) {
  $view = &$vars['view'];

  // Add JS for grid/list view switcher on DH and Collections views
  if ($view->name == 'digital_heritage_grid_list' OR $view->name == 'collections_grid_list') {
    drupal_add_library('system', 'jquery.cookie');
    drupal_add_js(drupal_get_path('module', 'ma_digitalheritage') . '/js/grid_list_switcher.js');
  }
}

/**
 * Implements hook_user_logout().
 */
// Delete the cookie that holds the DH grid/list view setting
function ma_digitalheritage_user_logout ($account) {
  setcookie('grid_list_mode', '', 1, '/');
}

/**
 * Implementation of hook_node_view().
 */
function ma_digitalheritage_node_view($node, $view_mode) {
  if ($view_mode == 'search_result') {

    // Tooltip and links on DH grid/list views


    // If no media items at all on the DH item and in grid view, put a placeholder image
    if (!count($node->field_media_asset)) {
      $node->content['field_media_asset'][0]['#markup'] = '
      <div class="col-md-4 col-md-push-8 field field-name-field-media-asset field-type-atom-reference field-label-hidden">
        <div class="field-items">
            <a class = "tooltips image-placeholder" href=" ' . url("node/" . $node->nid) . '"><img src = "/' . drupal_get_path('module', 'ma_digitalheritage') . '/images/no_media_available.jpg"></a>
        </div>
      </div>';
    }

  }

  elseif ($view_mode == 'full') {

    // Rewrite the Related DH Items reference field as paged, since there can be hundreds. This is a dupe of the same thing in ma_collection_node_view. See comments there if changing here, should also be changed there.

    $dh_items_per_page = 10;

    // Build the array of all DH items
    if (isset($node->field_related_dh_items[LANGUAGE_NONE])) {
      $all_dh_items = array();
      foreach ($node->field_related_dh_items[LANGUAGE_NONE] as $index => $dh_item) {
        unset ($node->content['field_related_dh_items'][$index]); // Start rewriting the field by removing the existing DH items
        if (node_access('view', $dh_item['entity'])) {
          $dh_node = node_view($dh_item['entity'], 'search_result');
          $all_dh_items[] = drupal_render($dh_node); // Need to render here as opposed to using "rendered entity" in the DS display, as that will attemt to render them *after* this hook runs
        }
      }

      // Initialise the pager
      $current_page = pager_default_initialize(count($all_dh_items), $dh_items_per_page);

      // Split all DH items into pages
      $pages = array_chunk($all_dh_items, $dh_items_per_page, TRUE);

      // Print the DH items for the current page
      $output = "";
      foreach ($pages[$current_page] as $dh_item_to_display) {
        $output .= $dh_item_to_display;
      }

      // Print the pager
      $output .= theme('pager', array('quantity', count($dh_items_per_page)));

      // Rewrite the field output
      $node->content['field_related_dh_items'][0]['#markup'] = $output;
    }


  }
  elseif ($view_mode == 'community_record') {

    // Add an edit link to community record after its title
    $node->content['title'][0]['#markup'] = $node->title . l (' (edit)', 'node/' . $node->nid . '/edit');
  }


}

/**
 * Implements hook_comment_insert().
 */
function ma_digitalheritage_comment_insert($comment) {

  // Notify protocol steward(s) when a comment has been posted to one of their Cultural Protocols that requires approval
  if ($comment->node_type == 'comment_node_digital_heritage') {
    if ($comment->status) return; // comment is pre-approved (eg. posted by admin)
    $dh_emw = entity_metadata_wrapper('node', $comment->nid);

    // Build the array of protcol manager emails from the protocol steward(s) of the given protocol(s) for this DH node
    if ($cps = $dh_emw->og_group_ref->value()) {
      $protocol_managers_emails = array();
      foreach ($cps as $cp) {
        $cp_emw = entity_metadata_wrapper('node', $cp);
        if ($protocol_managers = ma_core_og_get_users_per_role_and_group ('protocol steward', 'cultural_protocol_group', $cp->nid)) {
          foreach ($protocol_managers as $protocol_manager) {
            $protocol_managers_emails[] = $protocol_manager->name . ' <' . $protocol_manager->mail . '>';
          }
        }
      }

      // Send the email (the body and subject get built in ma_digitalheritage_mail)
      if (count($protocol_managers_emails)) {
        $params = array (
          'comment' => $comment,
          'cp_emw' => $cp_emw,
          'dh_emw' => $dh_emw,
          'recipient_count' => count ($protocol_managers_emails),
        );
        drupal_mail('ma_digitalheritage', 'dh_comment_notification', implode (', ', $protocol_managers_emails), language_default(), $params);
      }
    }
  }
}

/*
 * Implementation of hook_mail().
*/
function ma_digitalheritage_mail($key, &$message, $params) {
  switch ($key) {
    case 'dh_comment_notification':
      $comment = $params['comment'];
      $cp_title = $params['cp_emw']->title->value();

      // Set the email subject
      $message['subject'] = "A comment in '" . $cp_title . "' requires your approval";

      // Set the email body
      $email_body  = "A comment has been posted that requires your approval.\n\n";
      $email_body .= "Cultural Protocol:\n" . $cp_title . "\n\n";
      $email_body .= "Digital Heritage:\n" . $params['dh_emw']->title->value() . "\n\n";
      $comment_author = user_load ($comment->uid);
      $email_body .= "Comment author:\n" . $comment_author->name . "\n\n";
      if ($comment->subject) {
        $email_body .= "Comment subject:\n". $comment->subject . "\n\n";
      }
      $comment_body = $comment->comment_body[LANGUAGE_NONE][0]['value'];
      $comment_body = drupal_html_to_text ($comment_body);
      $email_body  .= "Comment body:\n" . $comment_body . "\n\n";
      $email_body .= "Click " . l('here', 'node/' . $comment->nid, array('fragment' => 'comment-' . $comment->cid)) . " to approve or delete this comment";
      if ($params['recipient_count'] > 1) {
        $email_body .= " (more than one Protocol Stewards have received this notification, so the comment may already be approved or deleted at this time)";
      }
      $email_body .= ".";
      $message['body'][] = $email_body;

      break;
  }
}

/**
 * Implements hook_views_pre_build().
 */
function ma_digitalheritage_views_pre_build(&$view) {

  // Override the "View All" (DH Items) path to the sapi page
  if ($view->name == 'community_dh_items') {
    $view->override_path = 'digital-heritage/' . $view->current_display;
  }
}

/**
 * Implements hook_menu().
 */
function ma_digitalheritage_menu() {
  $items = array();

  // "Duplicate Item" button for DH node
  $items['node/%node/duplicate-item'] = array(
    'title' => 'Duplicate Item',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ma_digitalheritage_clone_dh_form', 1),
    'access callback' => 'ma_digitalheritage_clone_dh_button_check',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  );

  // "Add Community Record" button for DH node
  $items['node/%node/add-community-record'] = array(
    'title' => 'Add Community Record',
    'page callback' => 'ma_digital_heritage_add_community_record',
    'page arguments' => array(1),
    'access callback' => 'ma_digitalheritage_clone_dh_button_check',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  );

  return $items;
}

function ma_digitalheritage_clone_dh_button_check($node) {
  if ($node->type == 'digital_heritage') {
    $protocol_manager_for_a_group = 0;
    $dh_emw = entity_metadata_wrapper('node', $node);
    foreach ($dh_emw->og_group_ref->value() as $protocol) {
      $p_emw = entity_metadata_wrapper('node', $protocol);
      $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
      if (array_intersect(array('protocol steward'), $roles_for_user_in_group)) {
        return TRUE;
      }
    }
  }
}

function ma_digitalheritage_clone_dh_form($form, $form_state, $node) {
  $question = "<i>Duplicate Digital Heritage Item</i> " . $node->title;
  $description = "<div>Are you sure?</div>";
  return confirm_form($form, $question, 'node/' . $node->nid, $description);
}

function ma_digitalheritage_clone_dh_form_submit($form, $form_state) {

  // Clone the node with a new title
  $original_nid = arg(1);
  $cloned = replicate_clone_entity_by_id ('node', $original_nid);
  $cloned->title = $cloned->title . ' - copy';
  node_save ($cloned);

  // Unset any CPs that the cloning protocol steward is not a contributor or protocol steward for
  $protocols_to_set = array();
  $dh_emw = entity_metadata_wrapper('node', $cloned);
  foreach ($dh_emw->og_group_ref->value() as $protocol) {
    $p_emw = entity_metadata_wrapper('node', $protocol);
    $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
    if (array_intersect(array('protocol steward', 'contributor'), $roles_for_user_in_group)) {
      $protocols_to_set[] = $protocol;
    }
  }
  $dh_emw->og_group_ref->set ($protocols_to_set);

  // Make a relationship to the original node
  $dh_emw->field_related_dh_items[] = $original_nid;

  // Save our changes
  $dh_emw->save();

  // Go to the cloned node
  drupal_set_message(t("Successfully duplicated Digital Heritage item"));
  drupal_goto ('node/' . $cloned->nid);
}

// When renaming a cloned node, do not create a URL redirect from the old node, because a newly cloned node from the original node might take the original path of 1st cloned node, thus you would always be redirected to the 1st cloned node from the 2nd cloned node. This is not an edge case. It would happen in normal node cloning workflow, as it did during our tests.
function ma_digitalheritage_redirect_presave($redirect) {
  if (strpos($redirect->source, '-copy')) {
    $redirect->source = "dh_clone_redirect"; // cannot simply unset the $redirect here so setting a dummy source instead
  }
}


// "Add Community Record" button redirect to node edit form with add-community-record param
function ma_digital_heritage_add_community_record ($node) {
  drupal_goto ('node/add/digital-heritage/community-record/' . $node->nid);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ma_digitalheritage_form_digital_heritage_node_form_alter(&$form, &$form_state) {

  // Grab Community Record parent on node edit and set page title
  if (isset($form['field_community_record_parent'][LANGUAGE_NONE]['#default_value'][0])) {
    $community_record_parent_wrapper = entity_metadata_wrapper('node', $form['field_community_record_parent'][LANGUAGE_NONE]['#default_value'][0]);

    // Set the page title
    drupal_set_title ("<i>Edit Community Record</i> " . $form['#node']->title . " <i>in</i> " . $community_record_parent_wrapper->title->value(),  PASS_THROUGH);
  }

  // On Community Record add, ensure the user actually has permission to create a community record on this node, in case they hacked NID in the url, and then set the community record parent wrapper and page title, and then set the session var for community record parent.
  elseif (arg(3) == 'community-record') {
    $parent_dh_wrapper = entity_metadata_wrapper('node', arg(4));
    foreach ($parent_dh_wrapper->og_group_ref->value() as $protocol) {
      $p_emw = entity_metadata_wrapper('node', $protocol);
      $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
      if (array_intersect(array('protocol steward'), $roles_for_user_in_group)) {

        // Set the parent wrapper
        $community_record_parent_wrapper = $parent_dh_wrapper;

        // Set the page title
        drupal_set_title ("<i>Create Community Record in</i> " . $community_record_parent_wrapper->title->value(),  PASS_THROUGH);

        // Use a session var to set the parent community record nid. This then gets set in the child in ma_digitalheritage_node_presave. (we cannot set the field value here because it is a hidden form element)
        $_SESSION['community_record_parent'] = arg(4);

        break;
      }
    }
  }

  // Customizations to Community Record DH nodes
  if (isset($community_record_parent_wrapper)) {

    // Hide some fields
    $hide_fields = array(
      'field_media_asset',
      'field_collection',
      'field_related_dh_items',
      'field_community_record_children',
    );
    foreach ($hide_fields as $hide_field) {
      $form[$hide_field]['#access'] = FALSE;
    }

  }

}

/**
 * Implements hook_node_validate().
 */
function ma_digitalheritage_node_validate($node, $form, &$form_state) {
  if ($node->type == 'digital_heritage') {

    // Do not allow adding, changing, or removing of Community Records in the DH node form. The field is there only to allow users to reorder the Community Records.
    $original_community_records = array();
    foreach ($form['field_community_record_children'][LANGUAGE_NONE] as $original_child) {
      if (isset($original_child['target_id'])) {
        $original_child_text = $original_child['target_id']['#default_value'];
        $original_child_numeric = substr(substr(strstr($original_child_text, '('), 0, -1), 1);
        if (is_numeric($original_child_numeric)) {
          $original_community_records[] = $original_child_numeric;
        }
      }
    }
    $new_community_records = array();
    foreach ($form_state['values']['field_community_record_children'][LANGUAGE_NONE] as $new_child) {
      if (isset($new_child['target_id']) && is_numeric($new_child['target_id'])) {
        $new_community_records[] = $new_child['target_id'];
        if (!in_array($new_child['target_id'], $original_community_records)) {
          form_set_error('field_community_record_children', t('Do not add Community Records here. Use the "Add Community Record" button instead.'));
        }
      }
    }
    foreach ($original_community_records as $original_child) {
      if (!in_array($original_child, $new_community_records)) {
        form_set_error('field_community_record_children', t('Do not remove Community Records here. Instead, edit the Community Record, then press "Delete". Note, only the creator of the Community Record can delete it.'));
      }

    }
  }
}


/**
 * Implements hook_node_insert().
 */
function ma_digitalheritage_node_insert($node) {
  if ($node->type == 'digital_heritage') {

    // Create redirects on Community Record nodes to their parent
    if (isset($node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'])) {
      $redirect = new stdClass();
      redirect_object_prepare(
        $redirect,
        array(
          'source' => 'node/' . $node->nid,
          'source_options' => array(),
          'redirect' => 'node/' . $node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'],
          'redirect_options' => array(),
          'language' => LANGUAGE_NONE,
        )
      );
      redirect_save($redirect);
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function ma_digitalheritage_node_delete($node) {
  if ($node->type == 'digital_heritage') {
    $dh_emw = entity_metadata_wrapper('node', $node);

    // Delete the Community Records of a parent DH if the parent is deleted
    foreach ($dh_emw->field_community_record_children->value() as $child) {
      if (isset($child->nid)) {
        node_delete ($child->nid);
      }
    }

  }
}

/**
 * Implements hook_search_api_index_items_alter().
 *
 * Exclude Community Record DH nodes from being indexed
 */
function ma_digitalheritage_search_api_index_items_alter(array &$items, SearchApiIndex $index) {
  foreach($items as $id => $item){
    if (isset($item->field_community_record_parent[LANGUAGE_NONE])) {
     unset($items[$id]);
    }
  }
}


/**
 * Implements hook_node_load().
 */
function ma_digitalheritage_node_load($nodes, $types) {

  // For Community Records, show the parent record's atoms
  if (in_array('digital_heritage', $types)) {
    foreach ($nodes as $node) {
      if (isset($node->field_community_record_parent[LANGUAGE_NONE])) {
        $parent_node = node_load ($node->field_community_record_parent[LANGUAGE_NONE][0]['target_id']);
        if (isset($parent_node->field_media_asset[LANGUAGE_NONE])) {
          $node->field_media_asset = $parent_node->field_media_asset;
        }
      }
    }
  }
}

/**
 * Implements hook_page_alter().
 */
function ma_digitalheritage_page_alter(&$data) {

  // If there are Child Records for a DH node, show the parent and child records in quicktabs
  if (isset($data['content']['system_main']['nodes'])) {
    $nids = element_children($data['content']['system_main']['nodes']);
    $nid = $nids[0];
    $parent_dh = entity_metadata_wrapper('node', $nid);
    if ($community_records = $parent_dh->field_community_record_children->value()) {

      $tab_settings = array(
        'ajax' => 0,
        'default_tab' => 0,
        'title' => 'DH Tabs',
        'renderer' => 'quicktabs',
        'style' => 'Zen',
      );

      $dh_tabs[] = array(
        'type' => 'node',
        'nid' => $nid,
        'view_mode' => 'full',
        'title' => 'Institutional Record',
        'hide_title' => 0,
        #'weight' => 0,
      );

      foreach ($community_records as $community_record) {

        // Tab title
        $community_record_parent_communities = array();
        foreach ($community_record->field_community_ref[LANGUAGE_NONE] as $community_record_parent_community) {
          $community_record_parent_community_node = node_load($community_record_parent_community['nid']);
          $community_record_parent_communities[] = $community_record_parent_community_node->title;
        }
        $community_record_tab_title = implode(' / ', $community_record_parent_communities) . ' Community Record';

        // Create the tab
        $dh_tabs[] = array(
          'type' => 'node',
          'nid' => $community_record->nid,
          'view_mode' => 'community_record',
          'title' => $community_record_tab_title,
          'hide_title' => 0,
          #'weight' => 0,
        );

      }

      $data['content']['system_main'] = array(
        'content' => quicktabs_build_quicktabs("dh_tabs", $tab_settings, $dh_tabs),
        '#weight' => 99,
      );
    }
  }
}