diff --git a/modules/image/image.module b/modules/image/image.module
index 526330c..cfcdc2b 100644
--- a/modules/image/image.module
+++ b/modules/image/image.module
@@ -1413,3 +1413,21 @@ function image_filter_keyword($value, $current_pixels, $new_pixels) {
 function _image_effect_definitions_sort($a, $b) {
   return strcasecmp($a['name'], $b['name']);
 }
+
+/**
+ * Converts a 24 bit RGB or 32 bit ARGB value to an RGBA array.
+ *
+ * @param int $argb
+ *   The color code to convert.
+ *
+ * @return array
+ *   An array containing the values for 'red', 'green', 'blue', 'alpha'.
+ */
+function _image_dec_to_rgba($argb) {
+  return array(
+    'red' => $argb >> 16 & 0xFF,
+    'green' => $argb >> 8 & 0xFF,
+    'blue' => $argb & 0xFF,
+    'alpha' => $argb >> 24 & 0xFF,
+  );
+}
diff --git a/modules/simpletest/tests/image.test b/modules/simpletest/tests/image.test
index 8497022..f742cda 100644
--- a/modules/simpletest/tests/image.test
+++ b/modules/simpletest/tests/image.test
@@ -419,7 +419,20 @@ class ImageToolkitGdTestCase extends DrupalWebTestCase {
         $correct_dimensions_object = TRUE;
         $correct_colors = TRUE;
 
-        // Check the real dimensions of the image first.
+        // PHP 5.5 GD bug: https://bugs.php.net/bug.php?id=65148. PHP 5.5 GD
+        // rotates differently then it did in PHP 5.4 resulting in different
+        // dimensions then what math teaches us. For the test images, the
+        // dimensions will be 1 pixel smaller in both dimensions (though other
+        // tests have shown a difference of 0 to 3 pixels in both dimensions.
+        // @todo: if and when the PHP bug gets solved, add an upper limit
+        //   version check.
+        // @todo: in [#1551686] the dimension calculations for rotation are
+        //   reworked. That issue should also check if these tests can be made
+        //   more robust.
+        if (version_compare(PHP_VERSION, '5.5', '>=') && $values['function'] === 'rotate' && $values['arguments'][0] % 90 != 0) {
+          $values['height']--;
+          $values['width']--;
+        }
         if (imagesy($image->resource) != $values['height'] || imagesx($image->resource) != $values['width']) {
           $correct_dimensions_real = FALSE;
         }
diff --git a/modules/system/image.gd.inc b/modules/system/image.gd.inc
index 913b0de..28ab3f0 100644
--- a/modules/system/image.gd.inc
+++ b/modules/system/image.gd.inc
@@ -98,10 +98,10 @@ function image_gd_resize(stdClass $image, $width, $height) {
  *   $image->info['height'] values will be modified by this call.
  * @param $degrees
  *   The number of (clockwise) degrees to rotate the image.
- * @param $background
- *   An hexadecimal integer specifying the background color to use for the
- *   uncovered area of the image after the rotation. E.g. 0x000000 for black,
- *   0xff00ff for magenta, and 0xffffff for white. For images that support
+ * @param int $background
+ *   An 24 bit or 32 bit ARGB value  specifying the background color to use for
+ *   the uncovered area of the image after the rotation. E.g. 0 for black,
+ *   16711935 for fuchsia, and 16777215 for white. For images that support
  *   transparency, this will default to transparent. Otherwise it will
  *   be white.
  * @return
@@ -116,38 +116,52 @@ function image_gd_rotate(stdClass $image, $degrees, $background = NULL) {
     return FALSE;
   }
 
-  $width = $image->info['width'];
-  $height = $image->info['height'];
+  // PHP 5.5 GD bug: https://bugs.php.net/bug.php?id=65148: To prevent buggy
+  // behavior on negative multiples of 90 degrees we convert any negative
+  // angle to a positive one between 0 and 360 degrees.
+  $degrees -= floor($degrees / 360) * 360;
 
-  // Convert the hexadecimal background value to a color index value.
   if (isset($background)) {
-    $rgb = array();
-    for ($i = 16; $i >= 0; $i -= 8) {
-      $rgb[] = (($background >> $i) & 0xFF);
-    }
-    $background = imagecolorallocatealpha($image->resource, $rgb[0], $rgb[1], $rgb[2], 0);
+    $background = _image_dec_to_rgba($background);
+    $background['alpha'] /= 2;
   }
-  // Set the background color as transparent if $background is NULL.
   else {
-    // Get the current transparent color.
-    $background = imagecolortransparent($image->resource);
-
-    // If no transparent colors, use white.
-    if ($background == 0) {
-      $background = imagecolorallocatealpha($image->resource, 255, 255, 255, 0);
-    }
+    // Background color is not specified: use transparent white as background.
+    $background = array('red' => 255, 'green' => 255, 'blue' => 255, 'alpha' => 127);
   }
 
+  // Store the color index for the background as that is what GD uses.
+  $background_idx = imagecolorallocatealpha($image->resource, $background['red'], $background['green'], $background['blue'], $background['alpha']);
+
   // Images are assigned a new color palette when rotating, removing any
   // transparency flags. For GIF images, keep a record of the transparent color.
   if ($image->info['extension'] == 'gif') {
-    $transparent_index = imagecolortransparent($image->resource);
-    if ($transparent_index != 0) {
-      $transparent_gif_color = imagecolorsforindex($image->resource, $transparent_index);
+    // GIF does not work with a transparency channel, but can define 1 color
+    // in its palette to act as transparent.
+
+    // Get the current transparent color, if any.
+    $gif_transparent_id = imagecolortransparent($image->resource);
+    if ($gif_transparent_id !== -1) {
+      // The gif already has a transparent color set: remember it to set it on
+      // the rotated image as well.
+      $transparent_gif_color = imagecolorsforindex($image->resource, $gif_transparent_id);
+
+      if ($background['alpha'] >= 127) {
+        // We want a transparent background: use the color already set to act
+        // as transparent, as background.
+        $background_idx = $gif_transparent_id;
+      }
+    }
+    else {
+      // The gif does not currently have a transparent color set.
+      if ($background['alpha'] >= 127) {
+        // But as the background is transparent, it should get one.
+        $transparent_gif_color = $background;
+      }
     }
   }
 
-  $image->resource = imagerotate($image->resource, 360 - $degrees, $background);
+  $image->resource = imagerotate($image->resource, 360 - $degrees, $background_idx);
 
   // GIFs need to reassign the transparent color after performing the rotate.
   if (isset($transparent_gif_color)) {
